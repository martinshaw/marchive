{"version":3,"file":"index.js","sourceRoot":"","sources":["../../src/index.ts"],"names":[],"mappings":"AAAA;;;;;;;;;EASE;AAEF,OAAO,MAAM,MAAM,QAAQ,CAAC;AAC5B,OAAO,UAAU,CAAA;AAEjB,OAAO,iBAAiB,MAAM,qBAAqB,CAAA;AACnD,OAAO,EAAE,oBAAoB,EAAE,MAAM,0CAA0C,CAAA;AAC/E,OAAO,EAAE,qBAAqB,EAAE,MAAM,+CAA+C,CAAA;AAErF,IAAI,YAAY,GAAoB,IAAI,CAAC;AAEzC,MAAM,kBAAkB,GAAG,KAAK,IAA2B,EAAE;IAC3D,MAAM,wBAAwB,GAAG,EAAE,GAAG,IAAI,CAAA,CAAC,aAAa;IAExD,OAAO,IAAI,EAAE;QACX,IAAI,0BAA0B,GAAG,MAAM,qBAAqB,CAAC,gCAAgC,CAAC,KAAK,IAAI,CAAA;QAEvG,IAAI;YACF,IAAI,0BAA0B,KAAK,KAAK;gBAAE,MAAM,IAAI,EAAE,CAAA;SACvD;QAAC,OAAO,KAAK,EAAE;YACd,IAAI,YAAY,IAAI,IAAI,EAAE;gBACxB,MAAM,CAAC,KAAK,CAAC,qDAAqD,YAAY,CAAC,EAAE,IAAI,YAAY,EAAE,CAAC,CAAA;gBACpG,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;gBAEnB;;;mBAGG;gBACH,kEAAkE;aACnE;SACF;QAED,MAAM,IAAI,OAAO,CAAC,OAAO,CAAC,EAAE;YAC1B,UAAU,CAAC,GAAG,EAAE,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE,wBAAwB,CAAC,CAAA;QAC3D,CAAC,CAAC,CAAA;KACH;AACH,CAAC,CAAA;AAED,MAAM,IAAI,GAAG,KAAK,IAAmB,EAAE;IACrC,MAAM,YAAY,GAAG,MAAM,oBAAoB,EAAE,CAAA;IAEjD,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC;QAAE,MAAM,CAAC,KAAK,CAAC,4BAA4B,CAAC,CAAA;IAEzE,YAAY,CAAC,OAAO,CAAC,KAAK,EAAC,QAAQ,EAAC,EAAE;QACpC,YAAY,GAAG,QAAQ,CAAA;QAEvB,MAAM,CAAC,IAAI,CAAC,kBAAkB,QAAQ,CAAC,EAAE,gBAAgB,CAAC,CAAA;QAE1D,iBAAiB,CAAC,QAAQ,CAAC;aACxB,KAAK,CAAC,KAAK,CAAC,EAAE;YACb,MAAM,CAAC,KAAK,CAAC,6BAA6B,QAAQ,CAAC,EAAE,kCAAkC,CAAC,CAAA;YACxF,MAAM,CAAC,KAAK,CAAC,KAAK,CAAC,CAAA;QACrB,CAAC,CAAC,CAAA;IACN,CAAC,CAAC,CAAA;AACJ,CAAC,CAAA;AAED,kBAAkB,EAAE,CAAA","sourcesContent":["/*\nAll Rights Reserved, (c) 2023 CodeAtlas LTD.\n\nAuthor: Martin Shaw (developer@martinshaw.co)\nFile Name: index.ts\nCreated:  2023-10-11T02:59:44.724Z\nModified: 2023-10-11T02:59:44.724Z\n\nDescription: description\n*/\n\nimport logger from 'logger';\nimport 'database'\nimport { Schedule } from 'database'\nimport performCaptureRun from \"./performCaptureRun\"\nimport { retrieveDueSchedules } from \"database/repositories/ScheduleRepository\"\nimport { getStoredSettingValue } from 'database/repositories/StoredSettingRepository'\n\nlet lastSchedule: Schedule | null = null;\n\nconst ScheduleRunProcess = async (): Promise<void | never> => {\n  const currentDelayBetweenTicks = 13 * 1000 // 13 seconds\n\n  while (true) {\n    let scheduleRunProcessIsPaused = await getStoredSettingValue('SCHEDULE_RUN_PROCESS_IS_PAUSED') === true\n\n    try {\n      if (scheduleRunProcessIsPaused === false) await tick()\n    } catch (error) {\n      if (lastSchedule != null) {\n        logger.error(`An error occurred when trying to process Schedule ${lastSchedule.id} ${lastSchedule}`)\n        logger.error(error)\n\n        /**\n         * Don't want to update the status of the Schedule to failed, as it may be due to a temporary\n         *   issue and we don't want to stop the Schedule from running future captures\n         */\n        // await lastSchedule.update({status: 'failed' as ScheduleStatus})\n      }\n    }\n\n    await new Promise(resolve => {\n      setTimeout(() => resolve(null), currentDelayBetweenTicks)\n    })\n  }\n}\n\nconst tick = async (): Promise<void> => {\n  const dueSchedules = await retrieveDueSchedules()\n\n  if (dueSchedules.length === 0) logger.debug('No Schedules due to be run')\n\n  dueSchedules.forEach(async schedule => {\n    lastSchedule = schedule\n\n    logger.info(`Found Schedule ${schedule.id} due to be run`)\n\n    performCaptureRun(schedule)\n      .catch(error => {\n        logger.error(`Error running Schedule ID ${schedule.id} in ScheduleRunProcess tick loop`)\n        logger.error(error)\n      })\n  })\n}\n\nScheduleRunProcess()"]}